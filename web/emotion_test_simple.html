<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ­ ê°ì • ì¸ì‹ - Emotion Cinema</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: white;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #e50914, #f40612);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .status-badge {
            display: inline-block;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
            margin: 5px;
        }

        .status-loading {
            background: #ff9800;
            color: white;
        }

        .status-ready {
            background: #4caf50;
            color: white;
        }

        .status-error {
            background: #f44336;
            color: white;
        }

        .main-container {
            display: flex;
            gap: 30px;
            max-width: 1200px;
            width: 100%;
        }

        .webcam-section {
            flex: 1;
            max-width: 500px;
        }

        .webcam-container {
            position: relative;
            background: #000;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            margin-bottom: 20px;
        }

        #webcam {
            width: 100%;
            height: auto;
            display: block;
            transform: scaleX(-1);
        }

        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            transform: scaleX(-1);
        }

        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #e50914 0%, #f40612 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(229, 9, 20, 0.4);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(229, 9, 20, 0.6);
        }

        .btn-secondary {
            background: #333;
            color: white;
            border: 1px solid #555;
        }

        .btn-secondary:hover {
            background: #444;
        }

        .btn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .results-section {
            flex: 1;
            min-width: 400px;
        }

        .card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid #333;
        }

        .card h3 {
            margin-bottom: 15px;
            font-size: 1.3rem;
            color: #fff;
        }

        .emotion-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }

        .emotion-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }

        .emotion-card.active {
            border-color: #e50914;
            background: rgba(229, 9, 20, 0.1);
            transform: scale(1.05);
        }

        .emotion-emoji {
            font-size: 2rem;
            margin-bottom: 8px;
            display: block;
        }

        .emotion-name {
            font-size: 14px;
            color: #ccc;
            margin-bottom: 5px;
        }

        .emotion-score {
            font-size: 1.5rem;
            font-weight: bold;
            color: #fff;
        }

        .navigation-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 30px;
            flex-wrap: wrap;
        }

        @media (max-width: 768px) {
            .main-container {
                flex-direction: column;
            }

            .header h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>

<body>
    <div class="header">
        <h1>ğŸ­ ê°ì • ì¸ì‹</h1>
        <p>ì–¼êµ´ í‘œì •ì„ ë¶„ì„í•˜ì—¬ ê°ì •ì„ ì¸ì‹í•©ë‹ˆë‹¤</p>
        <div id="statusBadges">
            <span class="status-badge status-loading">ğŸ”„ ì„œë²„ ì—°ê²° í™•ì¸ ì¤‘...</span>
        </div>
    </div>

    <div class="main-container">
        <div class="webcam-section">
            <div class="webcam-container">
                <video id="webcam" autoplay muted playsinline></video>
                <canvas id="overlay"></canvas>
            </div>

            <div class="controls">
                <button id="startBtn" class="btn btn-primary">ğŸ“¹ ì‹¤ì‹œê°„ ê°ì • ë¶„ì„</button>
                <button id="stopBtn" class="btn btn-secondary" disabled>â¹ï¸ ë¶„ì„ ì •ì§€</button>
                <button id="testBtn" class="btn btn-secondary">ğŸ§ª ì„œë²„ í…ŒìŠ¤íŠ¸</button>
                <button id="captureBtn" class="btn btn-secondary" disabled>ğŸ“¸ ì‚¬ì§„ ë¶„ì„</button>
                <button id="recommendBtn" class="btn btn-primary" disabled>ğŸ¬ ë§ì¶¤ ì˜í™” ì¶”ì²œ</button>
            </div>
        </div>

        <div class="results-section">
            <div class="card">
                <h3 id="currentStatus">ğŸ˜ ê°ì • ë¶„ì„ ëŒ€ê¸° ì¤‘...</h3>
                <p id="analysisInfo">ì„œë²„ ì—°ê²°ì„ í™•ì¸í•˜ê³  ë¶„ì„ì„ ì‹œì‘í•˜ì„¸ìš”</p>
            </div>

            <div class="card">
                <h3>ğŸ“Š ì‹¤ì‹œê°„ ê°ì • ë¶„ì„ ê²°ê³¼</h3>
                <div class="emotion-grid">
                    <div class="emotion-card" id="happyCard">
                        <span class="emotion-emoji">ğŸ˜Š</span>
                        <div class="emotion-name">ê¸°ì¨ (Happy)</div>
                        <div class="emotion-score" id="happyScore">0%</div>
                    </div>
                    <div class="emotion-card" id="sadCard">
                        <span class="emotion-emoji">ğŸ˜¢</span>
                        <div class="emotion-name">ìŠ¬í”” (Sad)</div>
                        <div class="emotion-score" id="sadScore">0%</div>
                    </div>
                    <div class="emotion-card" id="angryCard">
                        <span class="emotion-emoji">ğŸ˜ </span>
                        <div class="emotion-name">í™”ë‚¨ (Angry)</div>
                        <div class="emotion-score" id="angryScore">0%</div>
                    </div>
                    <div class="emotion-card" id="surprisedCard">
                        <span class="emotion-emoji">ğŸ˜®</span>
                        <div class="emotion-name">ë†€ëŒ (Surprised)</div>
                        <div class="emotion-score" id="surprisedScore">0%</div>
                    </div>
                    <div class="emotion-card" id="neutralCard">
                        <span class="emotion-emoji">ğŸ˜</span>
                        <div class="emotion-name">ë¬´í‘œì • (Neutral)</div>
                        <div class="emotion-score" id="neutralScore">0%</div>
                    </div>
                </div>
            </div>

            <div class="navigation-buttons">
                <button id="newAnalysisBtn" class="btn btn-primary">ğŸ”„ ìƒˆë¡œìš´ ê°ì • ë¶„ì„</button>
                <button id="homeBtn" class="btn btn-secondary">ğŸ  í™ˆí˜ì´ì§€ë¡œ</button>
            </div>
        </div>
    </div>

    <script>
        // ===== ê°ì • ì¸ì‹ ì‹œìŠ¤í…œ =====

        const API_BASE_URL = 'http://localhost:5000/api';

        let isAnalyzing = false;
        let analysisInterval = null;
        let video = null;
        let canvas = null;
        let ctx = null;
        let serverConnected = false;
        let currentEmotion = null; // í˜„ì¬ ê°ì • ìƒíƒœ ì €ì¥

        // DOM ìš”ì†Œë“¤
        const elements = {
            webcam: document.getElementById('webcam'),
            overlay: document.getElementById('overlay'),
            startBtn: document.getElementById('startBtn'),
            stopBtn: document.getElementById('stopBtn'),
            testBtn: document.getElementById('testBtn'),
            captureBtn: document.getElementById('captureBtn'),
            recommendBtn: document.getElementById('recommendBtn'),
            currentStatus: document.getElementById('currentStatus'),
            analysisInfo: document.getElementById('analysisInfo'),
            statusBadges: document.getElementById('statusBadges'),
            // ê°ì • ì ìˆ˜ë“¤
            happyScore: document.getElementById('happyScore'),
            sadScore: document.getElementById('sadScore'),
            angryScore: document.getElementById('angryScore'),
            surprisedScore: document.getElementById('surprisedScore'),
            neutralScore: document.getElementById('neutralScore'),
            // ê°ì • ì¹´ë“œë“¤
            happyCard: document.getElementById('happyCard'),
            sadCard: document.getElementById('sadCard'),
            angryCard: document.getElementById('angryCard'),
            surprisedCard: document.getElementById('surprisedCard'),
            neutralCard: document.getElementById('neutralCard'),
            // ë„¤ë¹„ê²Œì´ì…˜ ë²„íŠ¼ë“¤
            newAnalysisBtn: document.getElementById('newAnalysisBtn'),
            homeBtn: document.getElementById('homeBtn')
        };

        // í˜ì´ì§€ ë¡œë“œ ì‹œ ì´ˆê¸°í™”
        document.addEventListener('DOMContentLoaded', async function () {
            video = elements.webcam;
            canvas = elements.overlay;
            ctx = canvas.getContext('2d');

            setupEventListeners();
            await checkServerConnection();
        });

        // ì„œë²„ ì—°ê²° í™•ì¸
        async function checkServerConnection() {
            try {
                const response = await fetch(`${API_BASE_URL}/emotion-test`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                });

                if (response.ok) {
                    const data = await response.json();
                    serverConnected = true;

                    updateStatus('âœ… ì„œë²„ ì—°ê²° ì™„ë£Œ!', 'ready');
                    elements.analysisInfo.textContent = 'ì´ì œ ì‹¤ì‹œê°„ ê°ì • ë¶„ì„ì„ ì‹œì‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤';
                } else {
                    throw new Error(`ì„œë²„ ì‘ë‹µ ì˜¤ë¥˜: ${response.status}`);
                }

            } catch (error) {
                console.error('ì„œë²„ ì—°ê²° ì‹¤íŒ¨:', error);
                serverConnected = false;
                updateStatus('âŒ ì„œë²„ ì—°ê²° ì‹¤íŒ¨', 'error');
                elements.analysisInfo.textContent = 'API ì„œë²„ ì—°ê²°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ì„œë²„ë¥¼ ì‹œì‘í•´ì£¼ì„¸ìš”.';
            }
        }

        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì •
        function setupEventListeners() {
            elements.startBtn.addEventListener('click', startAnalysis);
            elements.stopBtn.addEventListener('click', stopAnalysis);
            elements.testBtn.addEventListener('click', testServer);
            elements.captureBtn.addEventListener('click', captureAndAnalyze);
            elements.recommendBtn.addEventListener('click', recommendMovies);
            elements.newAnalysisBtn.addEventListener('click', startNewAnalysis);
            elements.homeBtn.addEventListener('click', goToHome);
        }

        // ì„œë²„ í…ŒìŠ¤íŠ¸
        async function testServer() {
            await checkServerConnection();
        }

        // ë¶„ì„ ì‹œì‘
        async function startAnalysis() {
            if (!serverConnected) {
                await checkServerConnection();
                return;
            }

            try {
                isAnalyzing = true;
                elements.startBtn.disabled = true;
                elements.stopBtn.disabled = false;
                elements.captureBtn.disabled = false;

                // ì›¹ìº  ìŠ¤íŠ¸ë¦¼ ì‹œì‘
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: 640,
                        height: 480,
                        facingMode: 'user'
                    }
                });

                video.srcObject = stream;

                video.addEventListener('loadedmetadata', () => {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;

                    // ì‹¤ì‹œê°„ ê°ì • ë¶„ì„ ì‹œì‘
                    startRealTimeAnalysis();
                });

            } catch (error) {
                console.error('ì›¹ìº  ì‹œì‘ ì‹¤íŒ¨:', error);
                stopAnalysis();
            }
        }

        // ì‹¤ì‹œê°„ ê°ì • ë¶„ì„
        function startRealTimeAnalysis() {
            updateStatus('ğŸ” ì‹¤ì‹œê°„ ê°ì • ë¶„ì„ ì¤‘', 'ready');

            analysisInterval = setInterval(async () => {
                if (!isAnalyzing || !video.videoWidth || !video.videoHeight) return;

                try {
                    // í˜„ì¬ í”„ë ˆì„ì„ ìº”ë²„ìŠ¤ì— ê·¸ë¦¬ê¸°
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = video.videoWidth;
                    tempCanvas.height = video.videoHeight;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.drawImage(video, 0, 0);

                    // Base64ë¡œ ì¸ì½”ë”©
                    const imageData = tempCanvas.toDataURL('image/jpeg', 0.8);

                    // ë°±ì—”ë“œ API í˜¸ì¶œ
                    const response = await fetch(`${API_BASE_URL}/emotion-webcam`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            frame: imageData
                        })
                    });

                    const result = await response.json();

                    if (result.success && result.face_detected) {
                        // ì‹¤ì œ ê°ì • ê²°ê³¼ ì—…ë°ì´íŠ¸
                        updateEmotionDisplay(result.emotions);

                        // ì–¼êµ´ ë°•ìŠ¤ ê·¸ë¦¬ê¸°
                        if (result.face_box) {
                            drawFaceBox(result.face_box);
                        }

                        // ì£¼ìš” ê°ì • í‘œì‹œ
                        const maxEmotion = Object.keys(result.emotions).reduce((a, b) =>
                            result.emotions[a] > result.emotions[b] ? a : b
                        );
                        const confidence = result.emotions[maxEmotion];

                        if (confidence > 25) {
                            elements.currentStatus.textContent =
                                `${getEmotionEmoji(maxEmotion)} ${getEmotionName(maxEmotion)} ê°ì • ê°ì§€ë¨ (${confidence}%)`;
                        }
                    } else {
                        // ì–¼êµ´ì´ ê°ì§€ë˜ì§€ ì•ŠìŒ
                        elements.currentStatus.textContent = 'ğŸ˜ ì–¼êµ´ì´ ê°ì§€ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤';
                        resetEmotionScores();
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                    }

                } catch (error) {
                    console.error('ì‹¤ì‹œê°„ ë¶„ì„ ì˜¤ë¥˜:', error);
                }

            }, 1000); // 1ì´ˆë§ˆë‹¤ ë¶„ì„ (ì„œë²„ ë¶€í•˜ ê³ ë ¤)
        }

        // ì‚¬ì§„ ì´¬ì˜ í›„ ë¶„ì„
        async function captureAndAnalyze() {
            if (!serverConnected) {
                return;
            }

            try {
                // í˜„ì¬ í”„ë ˆì„ ìº¡ì²˜
                const captureCanvas = document.createElement('canvas');
                captureCanvas.width = video.videoWidth || 640;
                captureCanvas.height = video.videoHeight || 480;
                const captureCtx = captureCanvas.getContext('2d');
                captureCtx.drawImage(video, 0, 0);

                // Base64ë¡œ ì¸ì½”ë”©
                const imageData = captureCanvas.toDataURL('image/jpeg', 0.9);

                // ë°±ì—”ë“œ ê°ì • ë¶„ì„ API í˜¸ì¶œ
                const response = await fetch(`${API_BASE_URL}/analyze-emotion`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        image: imageData
                    })
                });

                const result = await response.json();

                if (result.success) {
                    updateEmotionDisplay(result.emotions);

                    // ê°ì • ë¶„ì„ ê²°ê³¼ë¥¼ ì˜¤ë˜ í‘œì‹œ
                    elements.currentStatus.textContent =
                        `${getEmotionEmoji(result.dominant_emotion.name)} ${getEmotionName(result.dominant_emotion.name)} (${result.dominant_emotion.confidence}%)`;

                    // ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ
                    const link = document.createElement('a');
                    link.href = imageData;
                    link.download = `emotion_analysis_${Date.now()}.jpg`;
                    link.click();
                }

            } catch (error) {
                console.error('ì‚¬ì§„ ë¶„ì„ ì˜¤ë¥˜:', error);
            }
        }

        // ì–¼êµ´ ë°•ìŠ¤ ê·¸ë¦¬ê¸°
        function drawFaceBox(faceBox) {
            if (!ctx || !faceBox) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const [x, y, width, height] = faceBox;

            // ì–¼êµ´ ë°•ìŠ¤
            ctx.strokeStyle = '#e50914';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, width, height);

            // ê°„ë‹¨í•œ í¬ì¸íŠ¸ë“¤
            ctx.fillStyle = '#e50914';
            const points = [
                [x + width * 0.3, y + height * 0.4], // ì™¼ìª½ ëˆˆ
                [x + width * 0.7, y + height * 0.4], // ì˜¤ë¥¸ìª½ ëˆˆ
                [x + width * 0.5, y + height * 0.6], // ì½”
                [x + width * 0.5, y + height * 0.8]  // ì…
            ];

            points.forEach(([px, py]) => {
                ctx.beginPath();
                ctx.arc(px, py, 2, 0, 2 * Math.PI);
                ctx.fill();
            });
        }

        // ê°ì • í‘œì‹œ ì—…ë°ì´íŠ¸
        function updateEmotionDisplay(emotions) {
            const emotionMapping = {
                happy: 'happyScore',
                sad: 'sadScore',
                angry: 'angryScore',
                surprised: 'surprisedScore',
                neutral: 'neutralScore'
            };

            const cardMapping = {
                happy: 'happyCard',
                sad: 'sadCard',
                angry: 'angryCard',
                surprised: 'surprisedCard',
                neutral: 'neutralCard'
            };

            // ëª¨ë“  ì¹´ë“œ ë¹„í™œì„±í™”
            Object.values(cardMapping).forEach(cardId => {
                const card = elements[cardId];
                if (card) card.classList.remove('active');
            });

            // ê°ì • ì ìˆ˜ ì—…ë°ì´íŠ¸
            Object.keys(emotions).forEach(emotion => {
                const scoreId = emotionMapping[emotion];
                const cardId = cardMapping[emotion];

                if (scoreId && elements[scoreId]) {
                    const percentage = Math.round(emotions[emotion]);
                    elements[scoreId].textContent = percentage + '%';

                    // ë†’ì€ ê°ì • ê°•ì¡°
                    if (percentage > 25 && cardId && elements[cardId]) {
                        elements[cardId].classList.add('active');
                    }
                }
            });

            // ê°€ì¥ ë†’ì€ ê°ì • ì°¾ê¸° ë° ì €ì¥
            const maxEmotion = Object.keys(emotions).reduce((a, b) =>
                emotions[a] > emotions[b] ? a : b
            );
            const confidence = Math.round(emotions[maxEmotion]);

            // í˜„ì¬ ê°ì • ì €ì¥ (ì˜í™” ì¶”ì²œìš©)
            currentEmotion = {
                emotion: maxEmotion,
                confidence: confidence,
                allEmotions: emotions
            };

            // ì¶”ì²œ ë²„íŠ¼ í™œì„±í™” (ì¼ì • ì‹ ë¢°ë„ ì´ìƒì¼ ë•Œ)
            if (confidence > 20) {
                elements.recommendBtn.disabled = false;
            }
        }

        // ê°ì • ì ìˆ˜ ì´ˆê¸°í™”
        function resetEmotionScores() {
            const scoreElements = [
                'happyScore', 'sadScore', 'angryScore', 'surprisedScore',
                'neutralScore'
            ];

            scoreElements.forEach(scoreId => {
                if (elements[scoreId]) {
                    elements[scoreId].textContent = '0%';
                }
            });

            const cardElements = [
                'happyCard', 'sadCard', 'angryCard', 'surprisedCard',
                'neutralCard'
            ];

            cardElements.forEach(cardId => {
                if (elements[cardId]) {
                    elements[cardId].classList.remove('active');
                }
            });
        }

        // ë¶„ì„ ì •ì§€
        function stopAnalysis() {
            isAnalyzing = false;

            if (analysisInterval) {
                clearInterval(analysisInterval);
                analysisInterval = null;
            }

            if (video.srcObject) {
                const tracks = video.srcObject.getTracks();
                tracks.forEach(track => track.stop());
                video.srcObject = null;
            }

            elements.startBtn.disabled = false;
            elements.stopBtn.disabled = true;
            elements.captureBtn.disabled = true;

            elements.currentStatus.textContent = 'ğŸ˜ ê°ì • ë¶„ì„ ëŒ€ê¸° ì¤‘...';
            resetEmotionScores();

            if (ctx) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
        }

        // ì˜í™” ì¶”ì²œ ë²„íŠ¼ í´ë¦­ ì‹œ ìƒˆ í˜ì´ì§€ë¡œ ì´ë™
        async function recommendMovies() {
            if (!serverConnected) {
                return;
            }

            if (!currentEmotion) {
                return;
            }

            // ìƒˆ í˜ì´ì§€ë¡œ ì´ë™í•˜ë©´ì„œ ê°ì • ì •ë³´ ì „ë‹¬
            const params = new URLSearchParams({
                emotion: currentEmotion.emotion,
                confidence: currentEmotion.confidence
            });

            window.location.href = `movie_recommendation.html?${params.toString()}`;
        }

        // ìƒˆë¡œìš´ ë¶„ì„ ì‹œì‘
        function startNewAnalysis() {
            elements.recommendBtn.disabled = true;
            currentEmotion = null;
            resetEmotionScores();
            elements.currentStatus.textContent = 'ğŸ˜ ê°ì • ë¶„ì„ ëŒ€ê¸° ì¤‘...';
        }

        // í™ˆí˜ì´ì§€ë¡œ ì´ë™
        function goToHome() {
            window.location.href = 'index.html';
        }

        // ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë“¤
        function getEmotionEmoji(emotion) {
            const emojis = {
                happy: 'ğŸ˜Š',
                sad: 'ğŸ˜¢',
                angry: 'ğŸ˜ ',
                surprised: 'ğŸ˜®',
                neutral: 'ğŸ˜'
            };
            return emojis[emotion] || 'ğŸ˜';
        }

        function getEmotionName(emotion) {
            const names = {
                happy: 'ê¸°ì¨',
                sad: 'ìŠ¬í””',
                angry: 'í™”ë‚¨',
                surprised: 'ë†€ëŒ',
                neutral: 'ë¬´í‘œì •'
            };
            return names[emotion] || 'ì•Œ ìˆ˜ ì—†ìŒ';
        }

        function updateStatus(message, type) {
            const badge = elements.statusBadges.querySelector('.status-badge');
            badge.textContent = message;
            badge.className = `status-badge status-${type}`;
        }

        console.log('ğŸ¤– ê°ì • ì¸ì‹ ì‹œìŠ¤í…œ ë¡œë“œ ì™„ë£Œ');
    </script>
</body>

</html>